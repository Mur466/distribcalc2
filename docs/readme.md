Distribcalc2 - Респределенный калькулятор версия 2 
=======

Автор https://t.me/Mur466

Краткое описание
=======
Это учебный проект к курсу go в Yandex лицее.
Приложение представляет собой калькулятор для распределенных вычислений. Центральный сервер получает арифметическое выражение через web-интерфейс или API (http/JSON). Он разбивает выражение на простейшие арифметические операции и передает их в нужном порядке агентам, которые проводят вычисление и передают на сервер результаты. Сервер получет результаты от агентов и по мере готовности передает к вычислению новые простейшие операции. Постепенно получается итоговый результат вычисления всего выражения.

Агентов может быть любое количество. Они общаются с сервером по gRPC.
У каждого агента несколько воркеров (по умолчанию 3), которые могут одновременно заниматься вычислениями.

Поддерживается авторизация пользователей сервера (JWT token) и разграничение доступа - отображение только своих выражений.


Инсталляция
===========

Вариант через Docker
--------------------
```
docker compose up -d
```
Создаются 4 контейнера:
- storage - база данных postgres
- server - орекстратор и веб-сервер
- agent1 - агент вычислений 1
- agent2 - агент вычислений 2

После запуска контейнеров web-интерфейса сервера доступна по адресу http://localhost:8080/

Вариант без Docker
------------------

См. инструкцию в файле docs\manual_setup.md


Регистрация и авторизация
=========================
Для начала работы нужно зарегистрировать пользователя через web-интерфейс. Ссылка на регистрацию доступна на странице логина. Необходимо задать логин и пароль.

После регистрации нужно авторизоваться с заданным логином/паролем, и можно приступать к вычислениям.

Отправка заданий и получение результатов
========================================

Поддержимаются простые арифметические операции над целыми числами и скобки  
Округление при некратном делении целых чисел происходит по правилам go

Примеры выражений
-----------------

- 4 * 3 / (2 + 1) результат 4
- -1-1 результат -2
- -(3+4) результат -7
- (1+1) * (2+2) * (3+3) * (4+4) * (5+5) * (6+6) * (7+7) результат 645120, пример для демонстрации параллельного вычисления разных частей одного выражения
- 9223372036854775802+9223372036854775802 результат overflow
- 4/(2-2) результат  division by zero

Web-интерфейс
-------------
- Раздел Tasks: ввод выражений, просмотр результатов. Для отслеживания динамики хода вычислений пользуйтесь кнопкой Refresh в браузере.
- Раздел Agents: мониториг агентов. Отображается количество воркеров общее и свободное, список вычисляемых операций, время последнего подключения агента к серверу.
- Раздел Config: настройка времени выполнения операций. Общая для всех пользователей и не сохраняется в БД. Считается как часть общей конфигурации системы, а не как пользовательские настройки.
- Кнопка Sign out: возможность сменить пользователя.

__Внимание!__ Статус выражения __ready__ означает, что оно распарсено и готово к передаче агентам. Когда агент придет за первой операцией, статус станет __in progress__, а когда посчитается всё выражение целиком, статус станет __done__. Именно в этот момент становится доступен результат вычисления.


API http/JSON
---
- /signin - залогиниться, получить JWT-token. Параметры: username и password
- /calculate-expression  - подать выражение на вычисление и получить его результат. Параметры: expr - выражение и ext_id - внешний идентификатор. При повторном обращении с старым ext_id возвращается статус и результат выражения, переданного впервые с этим ext_id. Уникальность ext_id контролируется для каждого пользователя. Выражения разных пользователей с одинаковым ext_id будут считаться разными выражениями.
- /signout - выйти из системы. JWT-token немедленно блокируется



Примеры вызовов API через curl
-----
### Логин, получение токена
```
Формат для *nix:
curl --location http://localhost:8080/signin --header "Content-Type: application/json" --data-raw '{ "username": "user1", "password": "1111" }'

Формат для Windows:
curl --location --request POST http://localhost:8080/signin --header "Content-Type: application/json" --data-raw "{ \"username\": \"user1\", \"password\": \"1111\" }"
```

### Отправка задания от клиента серверу и проверка результата

Нужно подменить строку после Authorization: Bearer и до закрывающей кавычки на JWT-токен, полученный при выполнении логина
```
Формат для *nix
curl http://localhost:8080/calculate-expression  --data '{"expr": "(1+2)/3*4", "ext_id": "SomeUniqId6543"}' --include --header "Content-Type: application/json" --header "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTM3MzMwMDgsImlhdCI6MTcxMzcyOTQwOCwibmJmIjoxNzEzNzI5NDA4LCJ1c2VybmFtZSI6InVzZXIxIn0.01yTNwrzHF0HJAKA85pNa0StX6ejiutyin_OpsrM550"

Формат для Widows
curl http://localhost:8080/calculate-expression  --request "POST" --data "{\"Expr\": \"(1+2)/3*4\", \"ext_id\": \"SomeUniqId6543\"}" --include --header "Content-Type: application/json" --header "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTM3MzMwMDgsImlhdCI6MTcxMzcyOTQwOCwibmJmIjoxNzEzNzI5NDA4LCJ1c2VybmFtZSI6InVzZXIxIn0.01yTNwrzHF0HJAKA85pNa0StX6ejiutyin_OpsrM550"
```
ext_id - уникальный идентификатор. При повторной отправке выражения с тем же идентификатором возвращается статус ранее переданного выражения
Если его не передать, то уникальность не контролируется. При этом видеть результат можно видеть через web-морду.
Но для получения результата через API ext_id - обязателен.

Архитектура приложения
======================

Диагарамма архитектуры
----------------------
https://excalidraw.com/#json=6bONZQpHHPUi9Gy0MDPPU,js_LoVZ5-tHoNuI6aejZYA
![Изображение](/docs/diagram.png)


Модули приложения
-----------------
### Агент
Выполняемый go-модуль. Выполняет вычисления простейших арифметических операций (из двух операндов). Выполняет gRPC вызовы, с ихпомщью получает задания от сервера и отдает результаты вычислений серверу. Может параллельно выполнять произвольное количество заданий в зависимости от настроек (количество воркеров). Можно запустить одновоременно несколько агентов.

### Сервер 
Выполняемый go-модуль. Получает задания от клиентов через API (http/JSON) и web-интерфейс. Разбивает сложные артифметические выражения на простейшие операции. По запросу агента выдает ему задание, готовое к вычислению. По запросу клиента получает результат вычислений и сохраняет. По мере готовности к вычислению следущих простейших операций, передает их агентам по их запросу. После выполнения всех входящих в выражение операций, сохраняет результат всего выражения. Отдает результат клиенту через  через API (http/JSON) и web-страницу. Может работать одновременно с произвольным количеством выражений и агентов, в том числе параллельно передавать разные операции одного выражения разным агентам. 


Архитектура агента
==================

Исходный код
------------
Весь агент находится в этом файле. Все остальные исходники относятся к серверу либо используются совместно сервером и агентом. 
   
\distribcalc\cmd\agent\main.go 

Конфигурация 
------------
Конфигурация выполняется через параметры командной строки
```

  -host string
        gRPC server host to get job from (default "127.0.0.1")
  -pollint int
        Poll interval (seconds) (default 15)
  -port string
        Port of the host (default "9090")
  -workers int
        Maximum number of workers (default 3)
```
Взаимодействие агента с сервером
-------------------------
Агент делает запросы к серверу и получает ответы. Используются вызовы gRPC. 
* Oper() - получить операцию для вычисления
* OperResult() - передать на сервер результат ранее полученной операции
* AgentStatus() - выполнить hearbeat и передать информацию для мониторинга

Авторизация не используется. Считаем, что мы в доверенной зоне.

Порядок работы агента
--------------

### Запуск
1. Агент стартует
2. Создает воркеров по числу указанных в параметрах (запускает горутины Worker)
3. Запускает TaskChecker(), который отвечает за получение заданий от сервера и передачу их воркерам, а также выполняет heartbeat (то есть пингует сервер в целях мониторинга)

### Получение заданий / heartbeat

TaskCheсker() по таймеру вызывает DinDon(). Если есть свободные воркеры, то GetOperation() получает задание от сервера. Если все заняты, SendHeartbeat() уведомляет сервер о присутствии агента.

### Вычисление и отправка результата
После получения задания горутина Worker() вычисляет результат и делает паузу согласно параметру, переданному вместе с операцией.
и передает результат на сервер вызовом SendResult()


Архитектура севера
==================

Система вычисления выражений
--------------------------
### Пакет internal/task
- struct Task - представление задания на расчет сложного выражения
- Глобальная мапа Tasks - все задания. Ключ мапы совпадает с идентификатором заания в БД
  В стуктуре Task есть слайс TreeSlice, который содержит все узлы AST-дерева (Abstract Syntax Tree)
- struct Node содержит арифметическую операцию и древовидную связь между операциями в AST-дереве (ссылку на родительский узел и оба дочерних узла). Node_id совпадает с индексом узла в TreeSlice.
  Сквозная уникальность нод обеспечивается парой task_id/node_id

### Пакет internal/agent
- struct Agent - информация о подкюченном агенте
- глобальная мапа Agents - полный список подключенных агентов

Состояния Task
--------------
- "parsing"  - еще не создано дерево арифметических операций (AST-дерево нод)
- "ready"    - AST дерево готово, ожидаем, когда первый агент придет за первой нодой (операцией)
- "in progress" - хотя бы одну операцию из дерева забрали на расчет
- "done"        - результаты вычисления всех операций получены. Результат всего выражения в поле Result
- "error"       - проблема при парсинге или вычислении. Описание проблемы в поле Message

Состояния Node
--------------
- "waiting"     - ожидаем вычисления подчиненных нод, передать на вычисление не можем
- "ready"       - нода готова к вычислению, ожидаем когда агент придет за нодой (операцией)
- "in progress" - операцию агент забрал на расчет
- "done"        - получен от агента результат операции. Результат всего выражения в поле Result
- "error"       - проблема при вычислении (деление на ноль или переполнение). Описание проблемы в поле Message

Аутентификация и авторизация
------------------------------
_При разработке авторизации попытался использовать подход со слоями транспорт/сервис/репозиторий, поэтому структура проекта в этой части отличается._
### Пакеты 
- internal/handlers/auth/register - хендлер регистрации
- internal/handlers/auth/signin - хендлер входа в систему
- internal/handlers/auth/signout - хендлер выхода из системы
- internal/middlewares - мидлвари для ограничения доступа и логирования
- internal/storage_fake - репозиторий на мапах использовался в процессе разработки функционала и может использоваться для тестов
- internal/storage_pg - репозиторий в БД Postgres

### Особенности
Используется аутентификация по JWT-токену.  
Для web-интерфейса токен хранится в куках.  
Выход из системы реализован через помещение токена в черный список. Список хранится в БД, то есть перезагрузка сервера не приведет к возможности входа с вылогиненным токеном.  


Сервер gRPC
----
Спецификация API находится в proto/mathoper.proto
### Пакеты
- grpc/mathoper - реализация интерфейсов API со стороны сервера
- grpc/grpcapp - App для инициализации, запуска и остановки gRPC сервера

Сервер HTTP
----------
Используется библиотека gin-gonic, с ней чуть короче синтаксис работы с http.

Для web-морды используется стандартный механизм шаблонов go.

Список endpoint'ов описан в internal/router:
- /config - страница конфигурации (время выполнения арифметических операций)
- /set-config - сохранение конфигурации
- /tasks - отображение списка заданий и ввод нового выражения через веб-морду
- /calculate-expression - передача от клиента нового выражения на расчет (через веб-морду и через API)
- /agents - мониторинг агентов
- /register - форма регистрации
- /signin - авторизация через форму или API
- /signout - выход их системы через форму или API



Сохранение состояния
--------------------
Состояние заданий и нод сохраняется в СУБД Postgres.


Исходный код
------------

- distribcalc\cmd\server
  - main.go - основной файл
- distribcalc\cmd\server\templates
  - *.html - шаблоны web-морды
- distribcalc\database 
  - скрипты для создания БД. См. readme.md
- distribcalc\docs 
  - документация
- distribcalc\internal 
  - пакеты *.go из которых состоит сервер и структуры данных общие для сервера и агента

Описание работы сервера
===============
Конфигурация
------------
Конфигурация выполняется через параметры командной строки
```
-agenttimeout int     
    Timeout before agent considered lost (seconds) (default 60)  
-authttl int    
    Timeout for auth token (seconds) (default 3600)    
-dbhost string     
    Postgress host (default "localhost")     
-dbname string     
    Postgress database name (default "distribcalc2")    
-dbpassword string     
    Postgress password (default "postgres")     
-dbport int    
    Posgress port to connect (default 5432)     
-dbuser string     
    Postgress user (default "postgres")     
-grpcport int    
    gRPC port to listen (default 9090)     
-httppport int     
    HTTP port to listen (default 8080)     
-secret string     
    JWT auth secret  

```
Получение задания и парсинг
---------------------------
- Сервер через /calculate-expression получает выражение.
- Проверяет на повторный ext_id. Если такой уже вычисляли, просто возвращает его резузультат
- если выражение новое, выполняет построение AST-дерева встроенной функцией GO parser.ParseExpr().
- далее в task.buildtree() делается построение слайса нод в порядке дерева и контроль, что узлы дерева содержать только арифметические операции и целые числа
- После завершения этого процесса task переходит в "ready", а все его ноды либо "ready" либо "waiting"

Вычисление
----------
- Сервер через /give-me-operation передает первое попавшуюся ноду в статусе "ready" агенту (Если агент пришел со статусом "ready"). 
  - Переводит ноду в "in progress", если задание еще в "ready", то его тоже в "in_porgress"
  - Если агент пришел со статусом "busy", то ноду ему не дают. 
  - Фиксируется LastSeenDate агента (и для "busy", и для "ready").
- Сервер через /take-operation-result получает результат ноды. 
  - Если результат "error", то задание переводится в "error", все ноды в "ready" и "waiting" переводятся в "error".
  - Если результат ноды "done", то фиксируется ее результат. 
  - Далее смотрим выше по дереву, если мы на верхнем уровне, то переводим task в "done" и фиксируем результат. 
  - Если есть родительский узел, сохраняем наш результат в один из его операндов.
  - Проверяем готов ли второй его операнд. Если да, то переводим его в "ready", чтобы его забрал агент при следующем обращении

Мониторинг
----------
Функции мониторинга заданий на странице /tasks:
- Статус задания
- Время получения
- Время получения результата
- В процессе вычисления виден прогресс, сколько всего нод и сколько из них уже вычислено

Функции мониторинга агентов на странице /agents
- список агентов
- время первого подключения агента
- время последнего обращения агента
- общее количество воркеров
- количество свободных воркеров
- список вычисляемых в данный момент операций

Параллельность
--------------
Выражения с операциями разного приоритета типа 1x1+2x2 или скобками типа (1+1)*(2+2) вычисляются параллельно разными агентами/воркерами (если есть свободные). В данном случае операции (1+1) и (2+2) будут вычислены параллельно, далее будет вычислено произведение скобок.

Отказоустойчивость
------------------
- Если агент не делал heartbeat в течение таймаута (берется максимальное время операции X 2), то он считается нерабочим. Вычеркивается из списка агентов. Если за ним числились ноды в статусе "in progress" они переводятся  "ready" и будут обработаны другими агентами. Для этих целей служит горутина CleanLostAgents()
- При старте сервера он читает Tasks из БД. Ноды в состоянии "in progress" переводятся в "ready".Если за время downtime сервера по ним агенты пытались прислать результат, который сервер не получил, ноды будут поданы в расчет повторно.
- Если по каким-то причинам результат ноды пришлет не тот агент, который забирал ее, сервер результат не принимает. Переводит ноду обратно в "ready" для повторного расчета.
- Перезапуск компонентов
- - Агент при выключении теряет вычисляемые выражения, но они будут переданы сервером другому агенту после таймаута
- - Сервер, пока выключен, не сможет получать новые задания и результаты от агентов. Но после старта повторно подаст на вычисление агентам операции, по которым он пропустил результат
- - База данных, пока выключена, скорее всего система будет не функциональна. После включения, функциональность должна восстановиться.








